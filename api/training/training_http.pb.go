// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// protoc-gen-go-http v2.1.4

package training

import (
	context "context"
	http "github.com/go-kratos/kratos/v2/transport/http"
	binding "github.com/go-kratos/kratos/v2/transport/http/binding"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL

const _ = http.SupportPackageIsVersion1

type TrainingHTTPServer interface {
	CreateTraining(context.Context, *CreateTrainingRequest) (*CreateTrainingReply, error)
	DeleteTraining(context.Context, *DeleteTrainingRequest) (*DeleteTrainingReply, error)
	GetTraining(context.Context, *GetTrainingRequest) (*GetTrainingReply, error)
	ListTraining(context.Context, *ListTrainingRequest) (*ListTrainingReply, error)
	UpdateTraining(context.Context, *UpdateTrainingRequest) (*UpdateTrainingReply, error)
}

func RegisterTrainingHTTPServer(s *http.Server, srv TrainingHTTPServer) {
	r := s.Route("/")
	r.POST("/training/create", _Training_CreateTraining0_HTTP_Handler(srv))
	r.POST("/training/update", _Training_UpdateTraining0_HTTP_Handler(srv))
	r.POST("/training/delete", _Training_DeleteTraining0_HTTP_Handler(srv))
	r.GET("/training/get/:id", _Training_GetTraining0_HTTP_Handler(srv))
	r.GET("/training/getList", _Training_ListTraining0_HTTP_Handler(srv))
}

func _Training_CreateTraining0_HTTP_Handler(srv TrainingHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in CreateTrainingRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/api.training.Training/CreateTraining")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.CreateTraining(ctx, req.(*CreateTrainingRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*CreateTrainingReply)
		return ctx.Result(200, reply)
	}
}

func _Training_UpdateTraining0_HTTP_Handler(srv TrainingHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in UpdateTrainingRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/api.training.Training/UpdateTraining")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.UpdateTraining(ctx, req.(*UpdateTrainingRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*UpdateTrainingReply)
		return ctx.Result(200, reply)
	}
}

func _Training_DeleteTraining0_HTTP_Handler(srv TrainingHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in DeleteTrainingRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/api.training.Training/DeleteTraining")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.DeleteTraining(ctx, req.(*DeleteTrainingRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*DeleteTrainingReply)
		return ctx.Result(200, reply)
	}
}

func _Training_GetTraining0_HTTP_Handler(srv TrainingHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetTrainingRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/api.training.Training/GetTraining")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetTraining(ctx, req.(*GetTrainingRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GetTrainingReply)
		return ctx.Result(200, reply)
	}
}

func _Training_ListTraining0_HTTP_Handler(srv TrainingHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ListTrainingRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/api.training.Training/ListTraining")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ListTraining(ctx, req.(*ListTrainingRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ListTrainingReply)
		return ctx.Result(200, reply)
	}
}

type TrainingHTTPClient interface {
	CreateTraining(ctx context.Context, req *CreateTrainingRequest, opts ...http.CallOption) (rsp *CreateTrainingReply, err error)
	DeleteTraining(ctx context.Context, req *DeleteTrainingRequest, opts ...http.CallOption) (rsp *DeleteTrainingReply, err error)
	GetTraining(ctx context.Context, req *GetTrainingRequest, opts ...http.CallOption) (rsp *GetTrainingReply, err error)
	ListTraining(ctx context.Context, req *ListTrainingRequest, opts ...http.CallOption) (rsp *ListTrainingReply, err error)
	UpdateTraining(ctx context.Context, req *UpdateTrainingRequest, opts ...http.CallOption) (rsp *UpdateTrainingReply, err error)
}

type TrainingHTTPClientImpl struct {
	cc *http.Client
}

func NewTrainingHTTPClient(client *http.Client) TrainingHTTPClient {
	return &TrainingHTTPClientImpl{client}
}

func (c *TrainingHTTPClientImpl) CreateTraining(ctx context.Context, in *CreateTrainingRequest, opts ...http.CallOption) (*CreateTrainingReply, error) {
	var out CreateTrainingReply
	pattern := "/training/create"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation("/api.training.Training/CreateTraining"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *TrainingHTTPClientImpl) DeleteTraining(ctx context.Context, in *DeleteTrainingRequest, opts ...http.CallOption) (*DeleteTrainingReply, error) {
	var out DeleteTrainingReply
	pattern := "/training/delete"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation("/api.training.Training/DeleteTraining"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *TrainingHTTPClientImpl) GetTraining(ctx context.Context, in *GetTrainingRequest, opts ...http.CallOption) (*GetTrainingReply, error) {
	var out GetTrainingReply
	pattern := "/training/get/:id"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation("/api.training.Training/GetTraining"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *TrainingHTTPClientImpl) ListTraining(ctx context.Context, in *ListTrainingRequest, opts ...http.CallOption) (*ListTrainingReply, error) {
	var out ListTrainingReply
	pattern := "/training/getList"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation("/api.training.Training/ListTraining"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *TrainingHTTPClientImpl) UpdateTraining(ctx context.Context, in *UpdateTrainingRequest, opts ...http.CallOption) (*UpdateTrainingReply, error) {
	var out UpdateTrainingReply
	pattern := "/training/update"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation("/api.training.Training/UpdateTraining"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}
